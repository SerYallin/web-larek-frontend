# Проектная работа "Веб-ларек"

Yandex Practicum проект на 8/9 курсе.

Данный проект предназначен для ознакомления в разработке веб-приложений с использованием проектирования MVP подхода.

В этом проекте мы создадим интернет-магазин с товарами для веб-разработчиков — Web-ларёк. В нём можно посмотреть каталог товаров, добавить товары в корзину и сделать заказ.


## Детали проекта

### Стек

- HTML
- SCSS
- TS
- Webpack

### Структура проекта

- `src/` — исходные файлы проекта
- `src/components/` — папка с JS компонентами
- `src/components/base/` — папка с базовым кодом

### Важные файлы

- `src/pages/index.html` — HTML-файл главной страницы
- `src/types/index.ts` — файл с типами
- `src/index.ts` — точка входа приложения
- `src/scss/styles.scss` — корневой файл стилей
- `src/utils/constants.ts` — файл с константами
- `src/utils/utils.ts` — файл с утилитами

### Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
### Сборка

```
npm run build
```

или

```
yarn build
```

## Анализ проекта WebLarek

### Анализ данных

Проведем анализ данного проекта. В этом проекте у нас всего одна страница. Эта страница включает следующие блоки:

1. Header. Шапка страницы содержит всего 2 компонента: логотип и корзина со счетчиком.
2. Content. Основной контент страницы, содержит каталог товаров.

При нажатии на каталог мы видим модальное окно с подробностями о товаре. В этом окне у нас есть кнопка с действием "В корзину" при нажатии на которое у нас товар добавляется в корзину.

Для того что перейти в корзину, нам нужно нажать на иконку в верхней правой части экрана.

В корзине мы можем удалить продукт либо перейти на форму заказа.

Форма заказа состоит из 2 этапов для заполнения полей: тип оплаты с адресом и электронна почта с номером телефона. После заполнения данных мы можем отправить заказ и получив подтверждение перейти на модальное окно с успешным заказом.

Так какие же данные участвуют в нашем процессе. Для этого ознакомимся с картинкой ниже:

![анализ приложения с точки зрения используемых данных](./doc/Writerside/images/page_analize.png "анализ приложения с точки зрения используемых данных")

Как видно из картинки у нас есть 2 модели отображения, это "Продукт" и "Форма". Посередине у нас презентер. Его роль в нашем проекте отвечает класс `EventsEmitter`. Через этот класс проходят все события, который позволяют общаться вьюверам с моделями. Рассмотрим модели подробнее.
Продукт у нас имеет такие данные:
- категория;
- название;
- картинка;
- описание;
- цена.

Форма у нас с такими полями:
- тип оплаты;
- адрес доставки;
- электронная почта;
- номер телефона.

При этом продукт у нас отображается в 3 разных представлениях:
- на главной странице в каталоге (отсутствует описание);
- в модальном окне с подробностями о товаре (все поля присутствуют);
- в корзине (отображается только название и цена).
  ![image](./doc/Writerside/images/product_views.png "Продукт в разных представлениях")

Общий процесс взаимодействия нашего приложения можно изобразить такой схемой:

![image](./doc/Writerside/images/use_case.png "Процесс взаимодействия компонентов приложения")

Как видно из рисунка, в нашем приложении будет 3 модели данных:
- Продукты(каталог)
- Корзина
- Ордер

Данное приложение является учебным, поэтому тут будет достаточно нам для работы с API только 2 метода:
- Получить список товаров
- Отправка заказа с его ответом.

В реальной задачи, нам бы понадобились: получение данных клиента, получения данных об оплате, получение всех ордеров, изменение ордеров, получение продукта оп его идентификатору и много другое...

### Анализ API.

Перед тем как приступить к разработке, нам нужно проанализировать API. В этом проекте мы использовали API предоставляемое Yandex.Practicum.
API состоит из следующих методов:
- `GET: /product/` - получение списка товаров;
- `GET: /product/{id}` - получение информации о конкретном товаре;
- `POST: /order` - создание заказа;

Данные которые получаем при получении товара:

```json
{
    "total": 10,
    "items": [
        {
            "id": "854cef69-976d-4c2a-a18c-2aa45046c390",
            "description": "Если планируете решать задачи в тренажёре, берите два.",
            "image": "/5_Dots.svg",
            "title": "+1 час в сутках",
            "category": "софт-скил",
            "price": 750
        },
      "..."
    ] 
}
```

Как видим, если сравнить модель продукта и данные что мы получаем - нам всего хватает.

Для формирования заказа необходимо передать следующие данные:

```json
{
    "payment": "online",
    "email": "test@test.ru",
    "phone": "+71234567890",
    "address": "Spb Vosstania 1",
    "total": 2200,
    "items": [
        "854cef69-976d-4c2a-a18c-2aa45046c390",
        "c101ab44-ed99-4a54-990d-47aa2bb4e7d9"
    ]
}
```

Контактные данные получаем из формы, продукты - из корзины, и общая цена - также из корзины.

В ответ в случае успешного создания заказа получаем:

```json
{
  "id": "98166951-4826-4d8f-a627-18adf7c92acb",
  "total": 2200
}     
```

Значение `total` мы можем использовать на странице подтверждения заказа. Если при заказе у нас возникла ошибка мы получаем:

```json
{
  "error": "Текст ошибки"
}    
```

Исходя из этих мы можем подвести итог, что данных для работы нашего приложения - достаточно и мы можем переходить к следующему шагу, а именно к разработке интерфейсов.

## Ключевые типы данных:

### Тип `TProduct`
Данный тип предназначен для хранения данных о продукте. Данный тип используется в таких моделях как список продуктов(`ProductList`), корзина(`Basket`) и заказ(`Order`).
Данный тип включает такие поля как: имя продукта(`name`), цена(`price`), описание(`description`), картинка(`image`), категория(`category`).

```ts
type TProduct = {
	name: string,
	price: number,
	description: string,
	image: string,
	category: number,
}
```

### Тип `TCategory`
Данный тип предназначен для хранения данных о категории продукта. Данный тип используется в таких моделях как список продуктов(`ProductList`), корзина(`Basket`) и заказ(`Order`) для отображения категории продукта.

```ts
type TCategory = {
	name: string,
}
```

### Интерфейс `ICollection`

Данный интерфейс используется для хранения списков продуктов, корзины и заказа. Он описывает такие методы как добавление элемента в список, получение по идентификатору, получение всех элементов и удаление элемента по идентификатору.

```ts
interface ICollection<Type> {
	_items: Map<string, Type>;
	addItem(item: Type): void
	getItems(): Type[];
	getItem(id: string): Type;
	removeItem(id: string): void;
}
```

### Интерфейс `BasketCollection`

Данный интерфейс используется для хранения заказа. Является дочерним от интерфейса `ICollection` и имеет дополнительные поля для хранения количества продуктов и общую стоимость.

```ts
interface BasketCollection<Type> extends ICollection<Type> {
	count: number;
	totalPrice: number;
}
```

### Интерфейс `ICollection`

Данный интерфейс используется для хранения списков корзины. Является дочерним от интерфейса `ICollection` и имеет дополнительные поля для хранения количества продуктов и данных заказа(оплата, адрес, почта, телефон, статус), а также метода получения статуса.

```ts
interface IOrder extends ICollection<TProduct> {

	_payment: string;
	_address: string;
	_email: string;
	_phone: string;
	_status: string;
	total: number;
	
	getStatus(): string;
}
```

### Интерфейс `AppInterface`

Данный интерфейс используется для хранения данных о продуктах, категориях, корзине и метода инициализации.

```ts
interface AppInterface {
	products: ICollection<TProduct>;
	categories: ICollection<TCategory>;
	basket: BasketCollection<TProduct>;
	init(): void;
}
```

### Интерфейс `IView`

Данный интерфейс используется для отображения данных. Он описывает метод `render`, который возвращает строку с HTML строкой блока.

```ts
interface IView {
	render(): string
}
```

## Описание классов.

При разработке проекта было использование следующих классов.

### Базовый код

#### Класс `Api`

Базовый класс для работы с API нашего приложения, основными функциями являются получение и отправка данных на сервер с помощью методов `get` и `post`.
Когда мы отправляем данные на сервер, в методе `post` мы можем указать параметр `ApiPostMethods`, в котором указывается метод отправки данных на сервер. По умолчанию `ApiPostMethods` установлен `POST`, но можно указать другое значение, такие как `PUT`, `DELETE`, `PATCH`.

#### Класс `EventEmitter`

Данный класс используется как утилита, которая позволяет управлять подписками на события. и таким образом помогает

Класс имеет методы `on`, `off`, `emit` — для подписки на событие, отписки от события и уведомления
подписчиков о наступлении события соответственно.
Дополнительно реализованы методы `onAll` и `offAll` — для подписки на все события и сброса всех
подписчиков.

Интересным дополнением является метод `trigger`, генерирующий заданное событие с заданными
аргументами. Это позволяет передавать его в качестве обработчика события в другие классы. Эти
классы будут генерировать события, не будучи при этом напрямую зависимыми от
класса `EventEmitter`.

### Классы моделей данных

#### Класс `ProductList`

Класс - модель для работы со списком продуктов по сути это просто коллекция продуктов. Основными функциями данного класса являются только получение списка продуктов;

#### Класс `Basket`

Класс - модель для работы с корзиной. Данный клас является так же как и `ProductList` коллекцией продуктов, только с той разницей, что тут у нас добавляются возможности добавлять продукт в коллекцию и удалять продукт из коллекции. Данный класс является потомков от `ProductList`.

#### Класс `Order`

Класс - модель для работы с заказом. Основными функциями данного класса отправка заказа на сервер и получение ответа.



### Компоненты представления.

Класс - модель для работы с заказом. Основными функциями данного класса отправка заказа на сервер и получение ответа.

#### Класс `View`

Базовый клас для вывода элемента на страницу. Основными функциями являются получение данных элемента и вывод его на страницу.

#### Класс `ProductView`

Производный класс от View основной функцией которого является вывод продукта на страницу согласно его типа(карта, детали или корзина).

#### Класс `BasketView`

Производный класс от View основной функцией которого является вывод корзины на страницу.

#### Класс `OrderFormView`

Производный класс от View основной функцией которого является вывод формы заказа на страницу.

#### Класс `SuccessView`

Производный класс от View основной функцией которого является вывод сообщения об успешном заказе на страницу.





